import type { Octokit } from "@octokit/core";
import type { Env } from "../types";
import { publishSchema, validatePythonTask, makeBranchName, makeFilePath } from "../utils/validation";
import { errorResponse, jsonResponse } from "../utils/responses";
import {
  createBranch,
  createOctokit,
  createOrUpdateFile,
  createPullRequest,
  fetchRegistryFile,
  formatRegistryJson,
  getRepoContext,
} from "../utils/github";

interface PublishResult {
  pullRequestUrl: string;
  pullRequestNumber: number;
  branch: string;
  taskPath: string;
}

function normalizePythonContent(content: string): string {
  return content.endsWith("\n") ? content : `${content}\n`;
}

function buildPrBody(options: {
  name: string;
  category: string;
  summary?: string;
  authorGithub?: string;
  taskPath: string;
}): string {
  const lines = [
    "## Summary",
    options.summary?.trim() || "Task generated via Task Wizard.",
    "",
    "## Details",
    `- Category: \`${options.category}\``,
    `- Task path: \`${options.taskPath}\``,
  ];
  if (options.authorGithub) {
    lines.push(`- Requested by: @${options.authorGithub}`);
  }
  lines.push(
    "",
    "## Checklist",
    "- [ ] Validate task config",
    "- [ ] Confirm task metadata in registry",
    "",
    "_Generated by TaskWizard Registry Bridge_",
  );
  return lines.join("\n");
}

async function ensureBranch(
  octokit: Octokit,
  env: Env,
  baseBranch: string,
  desiredBranch: string,
): Promise<string> {
  let attempt = 0;
  let branch = desiredBranch;
  while (attempt < 2) {
    try {
      await createBranch(octokit, env, branch, baseBranch);
      return branch;
    } catch (error) {
      const status = (error as { status?: number }).status;
      if (status === 422) {
        branch = `${desiredBranch}-${Math.random().toString(36).slice(2, 7)}`;
        attempt += 1;
        continue;
      }
      throw error;
    }
  }
  throw new Error("Failed to create a unique branch for publish request");
}

export async function handlePublish(
  request: Request,
  env: Env,
  ctx: ExecutionContext,
): Promise<Response> {
  const requiredSecrets: Array<keyof Env> = [
    "GITHUB_APP_ID",
    "GITHUB_PRIVATE_KEY",
    "GITHUB_INSTALLATION_ID",
  ];
  const missing = requiredSecrets.filter((key) => !env[key]);
  if (missing.length > 0) {
    return errorResponse(
      request,
      env,
      500,
      "Server credentials are not fully configured",
      { missing },
    );
  }

  let payload: unknown;
  try {
    payload = await request.json();
  } catch (error) {
    return errorResponse(request, env, 400, "Request body must be valid JSON");
  }

  const parsed = publishSchema.safeParse(payload);
  if (!parsed.success) {
    return errorResponse(request, env, 400, "Validation failed", parsed.error.format());
  }

  const data = parsed.data;
  const issues = validatePythonTask({ name: data.name, python: data.python });
  if (issues.length > 0) {
    return errorResponse(request, env, 400, "Python validation failed", { issues });
  }

  const taskPath = makeFilePath(data.category, data.name);
  const branchName = makeBranchName(data.name);
  const baseBranch = env.REGISTRY_DEFAULT_BRANCH || "main";

  if (data.dryRun) {
    return jsonResponse(
      {
        dryRun: true,
        branch: branchName,
        taskPath,
        message: "Validation passed (dry run).",
      },
      request,
      env,
    );
  }

  try {
    const octokit = createOctokit(env);
    const branch = await ensureBranch(octokit, env, baseBranch, branchName);

    // Ensure task does not already exist
    try {
      await octokit.request("GET /repos/{owner}/{repo}/contents/{path}", {
        ...getRepoContext(env),
        path: taskPath,
        ref: branch,
      });
      return errorResponse(request, env, 409, "Task file already exists", { path: taskPath });
    } catch (error) {
      const status = (error as { status?: number }).status;
      if (status && status !== 404) {
        throw error;
      }
    }

    // Create task file
    await createOrUpdateFile(octokit, env, {
      path: taskPath,
      branch,
      message: `Add ${data.name} task template`,
      content: normalizePythonContent(data.python),
    });

    // Update registry
    const registry = await fetchRegistryFile(octokit, env);
    if (registry.data.tasks.some((task) => task.name === data.name)) {
      return errorResponse(request, env, 409, "Registry already contains a task with this name");
    }
    if (registry.data.tasks.some((task) => task.path === taskPath)) {
      return errorResponse(request, env, 409, "Registry already references this file path");
    }

    registry.data.tasks.push({
      name: data.name,
      path: taskPath,
      ...(data.summary ? { summary: data.summary } : {}),
    });

    registry.data.tasks.sort((a, b) => a.name.localeCompare(b.name));

    await createOrUpdateFile(octokit, env, {
      path: "registry.json",
      branch,
      message: `Register ${data.name} task`,
      content: formatRegistryJson(registry.data),
      sha: registry.sha,
    });

    const pr = await createPullRequest(octokit, env, {
      title: `Add ${data.name} task template`,
      head: branch,
      base: baseBranch,
      body: buildPrBody({
        name: data.name,
        category: data.category,
        summary: data.summary,
        authorGithub: data.authorGithub,
        taskPath,
      }),
    });

    const result: PublishResult = {
      pullRequestUrl: pr.url,
      pullRequestNumber: pr.number,
      branch,
      taskPath,
    };

    return jsonResponse({ ok: true, result }, request, env, { status: 201 });
  } catch (error) {
    const message = error instanceof Error ? error.message : "Unexpected error";
    const status = (error as { status?: number }).status;
    return errorResponse(request, env, status && status >= 400 && status < 600 ? status : 500, message, {
      hint: "Check Cloudflare logs for full stack trace.",
    });
  }
}
